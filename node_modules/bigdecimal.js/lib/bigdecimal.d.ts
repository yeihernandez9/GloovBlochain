/**
 * Specifies a `rounding policy` for numerical operations capable
 * of discarding precision. Each rounding mode indicates how the least
 * significant returned digit of a rounded result is to be calculated.
 * If fewer digits are returned than the digits needed to represent
 * the exact numerical result, the discarded digits will be referred
 * to as the `discarded fraction` regardless the digits'
 * contribution to the value of the number.  In other words,
 * considered as a numerical value, the discarded fraction could have
 * an absolute value greater than one.
 *
 * Each rounding mode description includes a table listing how
 * different two-digit decimal values would round to a one digit
 * decimal value under the rounding mode in question. The result
 * column in the tables could be gotten by creating a
 * `BigDecimal` number with the specified value, forming a
 * {@link MathContext} object with the proper settings
 * (`precision` set to `1`, and the `roundingMode` set to the rounding
 * mode in question), and calling {@link BigDecimal.round | round} on
 * this number with the proper `MathContext`.  A summary table showing the results
 * of these rounding operations for all rounding modes appears below.
 *
 * | Input | UP | DOWN | CEILING | FLOOR | HALF_UP | HALF_DOWN | HALF_EVEN | UNNECESSARY |
 * | --- | --- | --- | --- | --- | --- | --- | --- | --- |
 * | 5.5 | 6 | 5 | 6 | 5 | 6 | 5 | 6 | RangeError |
 * | 2.5 | 3 | 2 | 3 | 2 | 3 | 2 | 2 | RangeError |
 * | 1.6 | 2 | 1 | 2 | 1 | 2 | 2 | 2 | RangeError |
 * | 1.1 | 2 | 1 | 2 | 1 | 1 | 1 | 1 | RangeError |
 * | 1.0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
 * | -1.0 | -1 | -1 | -1 | -1 | -1 | -1 | -1 | -1 |
 * | -1.1 | -2 | -1 | -1 | -2 | -1 | -1 | -1 | RangeError |
 * | -1.6 | -2 | -1 | -1 | -2 | -2 | -2 | -2 | RangeError |
 * | -2.5 | -3 | -2 | -2 | -3 | -3 | -2 | -2 | RangeError |
 * | -5.5 | -6 | -5 | -5 | -6 | -6 | -5 | -6 | RangeError |
 *
 */
export declare enum RoundingMode {
    /**
     * Rounding mode to round away from zero.  Always increments the
     * digit prior to a non-zero discarded fraction.  Note that this
     * rounding mode never decreases the magnitude of the calculated
     * value.
     */
    UP = 0,
    /**
     * Rounding mode to round towards zero.  Never increments the digit
     * prior to a discarded fraction (i.e., truncates).  Note that this
     * rounding mode never increases the magnitude of the calculated value.
     * This mode corresponds to the IEEE 754-2019 rounding-direction
     * attribute "roundTowardZero".
     */
    DOWN = 1,
    /**
     * Rounding mode to round towards positive infinity.  If the
     * result is positive, behaves as for `RoundingMode.UP`;
     * if negative, behaves as for `RoundingMode.DOWN`.  Note
     * that this rounding mode never decreases the calculated value.
     * This mode corresponds to the IEEE 754-2019 rounding-direction
     * attribute "roundTowardPositive".
     */
    CEILING = 2,
    /**
     * Rounding mode to round towards negative infinity.  If the
     * result is positive, behave as for `RoundingMode.DOWN`;
     * if negative, behave as for `RoundingMode.UP`.  Note that
     * this rounding mode never increases the calculated value.
     * This mode corresponds to the IEEE 754-2019 rounding-direction
     * attribute "roundTowardNegative".
     */
    FLOOR = 3,
    /**
     * Rounding mode to round towards "nearest neighbor"
     * unless both neighbors are equidistant, in which case round up.
     * Behaves as for `RoundingMode.UP` if the discarded
     * fraction is &ge; 0.5; otherwise, behaves as for
     * `RoundingMode.DOWN`.  Note that this is the rounding
     * mode commonly taught at school.
     * This mode corresponds to the IEEE 754-2019 rounding-direction
     * attribute "roundTiesToAway".
     */
    HALF_UP = 4,
    /**
     * Rounding mode to round towards "nearest neighbor"
     * unless both neighbors are equidistant, in which case round
     * down.  Behaves as for `RoundingMode.UP` if the discarded
     * fraction is &gt; 0.5; otherwise, behaves as for
     * `RoundingMode.DOWN`.
     */
    HALF_DOWN = 5,
    /**
     * Rounding mode to round towards the "nearest neighbor"
     * unless both neighbors are equidistant, in which case, round
     * towards the even neighbor.  Behaves as for
     * `RoundingMode.HALF_UP` if the digit to the left of the
     * discarded fraction is odd; behaves as for
     * `RoundingMode.HALF_DOWN` if it's even.  Note that this
     * is the rounding mode that statistically minimizes cumulative
     * error when applied repeatedly over a sequence of calculations.
     * It is sometimes known as "Banker's rounding," and is
     * chiefly used in the USA.
     * This mode corresponds to the IEEE 754-2019 rounding-direction
     * attribute "roundTiesToEven".
     */
    HALF_EVEN = 6,
    /**
     * Rounding mode to assert that the requested operation has an exact
     * result, hence no rounding is necessary.  If this rounding mode is
     * specified on an operation that yields an inexact result, an
     * `RangeError` is thrown.
     */
    UNNECESSARY = 7
}
/**
 * Immutable objects which encapsulate the context settings which
 * describe certain rules for numerical operators, such as those
 * implemented by the {@link BigDecimal} class.
 *
 * The base-independent settings are:
 *
 * * precision: the number of digits to be used for an operation; results are
 * rounded to this precision
 * * roundingMode: a {@link RoundingMode} object which specifies the algorithm to be
 * used for rounding.
 *
 * Sample Usage:
 * ```javascript
 * const { Big, MC, RoundingMode } = require('bigdecimal.js');
 *
 * const x = Big('1');
 * const y = Big('3');
 *
 * const res1 = x.divideWithMathContext(y, new MC(3));
 * console.log(res1.toString()); // 0.333
 *
 * // You can also use without `new` operator
 * const res2 = x.divideWithMathContext(y, MC(3, RoundingMode.UP));
 * console.log(res2.toString()); // 0.334
 *
 * try {
 *     x.divide(y);
 *     // throws since full precision is requested but it is not possible
 * } catch (e) {
 *     console.log(e); // RangeError: Non-terminating decimal expansion; no exact representable decimal result.
 * }
 * ```
 */
export declare class MathContext {
    /**
     * The number of digits to be used for an operation.  A value of 0
     * indicates that unlimited precision (as many digits as are
     * required) will be used.  Note that leading zeros (in the
     * coefficient of a number) are never significant.
     *
     * `precision` will always be non-negative.
     */
    readonly precision: number;
    /**
     * The rounding algorithm to be used for an operation. By default it is `HALF_UP`.
     *
     * see {@link RoundingMode}
     */
    readonly roundingMode: RoundingMode;
    constructor(precision: number, roundingMode?: RoundingMode);
    /**
     * A `MathContext` object whose settings have the values
     * required for unlimited precision arithmetic.
     * The values of the settings are: `precision=0 roundingMode=HALF_UP`
     */
    static UNLIMITED: MathContext;
    /**
     * A `MathContext` object with a precision setting
     * matching the precision of the IEEE 754-2019 decimal32 format, 7 digits, and a
     * rounding mode of {@link RoundingMode.HALF_EVEN |  HALF_EVEN}.
     * Note the exponent range of decimal32 is **not** used for
     * rounding.
     */
    static DECIMAL32: MathContext;
    /**
     * A `MathContext` object with a precision setting
     * matching the precision of the IEEE 754-2019 decimal64 format, 16 digits, and a
     * rounding mode of {@link RoundingMode.HALF_EVEN | HALF_EVEN}.
     * Note the exponent range of decimal64 is **not** used for
     * rounding.
     */
    static DECIMAL64: MathContext;
    /**
     * A `MathContext` object with a precision setting
     * matching the precision of the IEEE 754-2019 decimal128 format, 34 digits, and a
     * rounding mode of {@link RoundingMode.HALF_EVEN | HALF_EVEN}.
     * Note the exponent range of decimal64 is **not** used for
     * rounding.
     */
    static DECIMAL128: MathContext;
}
/**
 * [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) based BigDecimal
 * implementation. This class is ported from java.math.BigDecimal. The following documentation is adapted from openjdk/jdk
 * repository.
 *
 * Immutable, arbitrary-precision signed decimal numbers.  A
 * `BigDecimal` consists of an arbitrary precision number
 * {@link unscaledValue | unscaled value} and a {@link scale | scale}.
 * If zero or positive, the scale is the number of digits to the right of the decimal
 * point. If negative, the unscaled value of the number is multiplied
 * by ten to the power of the negation of the scale.  The value of the
 * number represented by the `BigDecimal` is therefore
 * <code>(unscaledValue &times; 10<sup>-scale</sup>)</code>.
 *
 * The `BigDecimal` class provides operations for
 * arithmetic, scale manipulation, rounding, comparison, hashing, and
 * format conversion.  The {@link toString} method provides a
 * canonical representation of a `BigDecimal`.
 *
 * The `BigDecimal` class gives its user complete control
 * over rounding behavior.  If no rounding mode is specified and the
 * exact result cannot be represented, a `RangeError`
 * is thrown; otherwise, calculations can be carried out to a chosen
 * precision and rounding mode by supplying an appropriate {@link
 * MathContext} object to the operation.  In either case, eight
 * <em>rounding modes</em> are provided for the control of rounding.
 *
 * When a `MathContext` object is supplied with a precision
 * setting of 0 (for example, {@link MathContext.UNLIMITED}),
 * arithmetic operations are exact, as are the arithmetic methods
 * which take no `MathContext` object. As a corollary of
 * computing the exact result, the rounding mode setting of a `
 * MathContext` object with a precision setting of 0 is not used and
 * thus irrelevant.  In the case of divide, the exact quotient could
 * have an infinitely long decimal expansion; for example, 1 divided
 * by 3.  If the quotient has a non-terminating decimal expansion and
 * the operation is specified to return an exact result, a RangeError
 * is thrown.  Otherwise, the exact result of the
 * division is returned, as done for other operations.
 *
 * When the precision setting is not 0, the rules of `BigDecimal`
 * arithmetic are broadly compatible with selected modes
 * of operation of the arithmetic defined in ANSI X3.274-1996 and ANSI
 * X3.274-1996/AM 1-2000 (section 7.4).  Unlike those standards,
 * `BigDecimal` includes many rounding modes.  Any conflicts
 * between these ANSI standards and the `BigDecimal`
 * specification are resolved in favor of `BigDecimal`.
 *
 * Since the same numerical value can have different
 * representations (with different scales), the rules of arithmetic
 * and rounding must specify both the numerical result and the scale
 * used in the result's representation.
 *
 * The different representations of the same numerical value are
 * called members of the same <i>cohort</i>. The {@link
 * compareTo |  natural order} of `BigDecimal`
 * considers members of the same cohort to be equal to each other. In
 * contrast, the {@link equals | equals} method requires both the
 * numerical value and representation to be the same for equality to
 * hold. The results of methods like {@link scale} and {@link
 * unscaledValue} will differ for numerically equal values with
 * different representations.
 *
 * In general the rounding modes and precision setting determine
 * how operations return results with a limited number of digits when
 * the exact result has more digits (perhaps infinitely many in the
 * case of division and square root) than the number of digits returned.
 *
 * First, the total number of digits to return is specified by the
 * `MathContext`'s `precision` setting; this determines
 * the result's <i>precision</i>.  The digit count starts from the
 * leftmost nonzero digit of the exact result.  The rounding mode
 * determines how any discarded trailing digits affect the returned
 * result.
 *
 * For all arithmetic operators, the operation is carried out as
 * though an exact intermediate result were first calculated and then
 * rounded to the number of digits specified by the precision setting
 * (if necessary), using the selected rounding mode.  If the exact
 * result is not returned, some digit positions of the exact result
 * are discarded.  When rounding increases the magnitude of the
 * returned result, it is possible for a new digit position to be
 * created by a carry propagating to a leading "9" digit.
 * For example, rounding the value 999.9 to three digits rounding up
 * would be numerically equal to one thousand, represented as
 * 100&times;10<sup>1</sup>.  In such cases, the new "1" is
 * the leading digit position of the returned result.
 *
 * For methods and constructors with a `MathContext`
 * parameter, if the result is inexact but the rounding mode is {@link
 * RoundingMode.UNNECESSARY | UNNECESSARY}, a RangeError will be thrown.
 *
 * Besides a logical exact result, each arithmetic operation has a
 * preferred scale for representing a result.  The preferred
 * scale for each operation is listed in the table below.
 *
 * <table class="striped" style="text-align:left">
 * <caption>Preferred Scales for Results of Arithmetic Operations
 * </caption>
 * <thead>
 * <tr><th scope="col">Operation</th><th scope="col">Preferred Scale of Result</th></tr>
 * </thead>
 * <tbody>
 * <tr><th scope="row">Add</th><td>max(addend.scale(), augend.scale())</td>
 * <tr><th scope="row">Subtract</th><td>max(minuend.scale(), subtrahend.scale())</td>
 * <tr><th scope="row">Multiply</th><td>multiplier.scale() + multiplicand.scale()</td>
 * <tr><th scope="row">Divide</th><td>dividend.scale() - divisor.scale()</td>
 * <tr><th scope="row">Square root</th><td>radicand.scale()/2</td>
 * </tbody>
 * </table>
 *
 * These scales are the ones used by the methods which return exact
 * arithmetic results; except that an exact divide may have to use a
 * larger scale since the exact result may have more digits.  For
 * example, `1/32` is `0.03125`.
 *
 * Before rounding, the scale of the logical exact intermediate
 * result is the preferred scale for that operation. If the exact
 * numerical result cannot be represented in `precision`
 * digits, rounding selects the set of digits to return and the scale
 * of the result is reduced from the scale of the intermediate result
 * to the least scale which can represent the `precision`
 * digits actually returned.  If the exact result can be represented
 * with at most `precision` digits, the representation
 * of the result with the scale closest to the preferred scale is
 * returned.  In particular, an exactly representable quotient may be
 * represented in fewer than `precision` digits by removing
 * trailing zeros and decreasing the scale.  For example, rounding to
 * three digits using the {@link RoundingMode.FLOOR | floor}
 * rounding mode, <br>
 *
 * `19/100 = 0.19   // number=19,  scale=2` <br>
 *
 * but<br>
 *
 * `21/110 = 0.190  // number=190, scale=3` <br>
 *
 * Note that for add, subtract, and multiply, the reduction in
 * scale will equal the number of digit positions of the exact result
 * which are discarded. If the rounding causes a carry propagation to
 * create a new high-order digit position, an additional digit of the
 * result is discarded than when no new digit position is created.
 *
 * Other methods may have slightly different rounding semantics.
 * For example, the result of the `pow` method using the
 * {@link pow | specified algorithm} can
 * occasionally differ from the rounded mathematical result by more
 * than one unit in the last place, one <i>{@link ulp}</i>.
 *
 * Two types of operations are provided for manipulating the scale
 * of a `BigDecimal`: scaling/rounding operations and decimal
 * point motion operations.  Scaling/rounding operations ({@link
 * setScale} and {@link round}) return a
 * `BigDecimal` whose value is approximately (or exactly) equal
 * to that of the operand, but whose scale or precision is the
 * specified value; that is, they increase or decrease the precision
 * of the stored number with minimal effect on its value.  Decimal
 * point motion operations ({@link movePointLeft} and
 * {@link movePointRight}) return a
 * `BigDecimal` created from the operand by moving the decimal
 * point a specified distance in the specified direction.
 *
 * As a number, the set of values for the scale is large,
 * but bounded. If the scale of a result would exceed the range of a
 * safe number, either by overflow or underflow, the operation may
 * throw a RangerError.
 *
 * For the sake of brevity and clarity, pseudo-code is used
 * throughout the descriptions of `BigDecimal` methods.  The
 * pseudo-code expression `(i + j)` is shorthand for "a
 * `BigDecimal` whose value is that of the `BigDecimal`
 * `i` added to that of the `BigDecimal`
 * `j`." The pseudo-code expression `(i == j)` is
 * shorthand for "`true` if and only if the
 * `BigDecimal` `i` represents the same value as the
 * `BigDecimal` `j`." Other pseudo-code expressions
 * are interpreted similarly.  Square brackets are used to represent
 * the particular `BigInt` and scale pair defining a
 * `BigDecimal` value; for example [19, 2] is the
 * `BigDecimal` numerically equal to 0.19 having a scale of 2.
 *
 * <h2>Relation to IEEE 754 Decimal Arithmetic</h2>
 *
 * Starting with its 2008 revision, the <cite>IEEE 754 Standard for
 * Floating-point Arithmetic</cite> has covered decimal formats and
 * operations. While there are broad similarities in the decimal
 * arithmetic defined by IEEE 754 and by this class, there are notable
 * differences as well. The fundamental similarity shared by
 * `BigDecimal` and IEEE 754 decimal arithmetic is the conceptual
 * operation of computing the mathematical infinitely precise real
 * number value of an operation and then mapping that real number to a
 * representable decimal floating-point value under a <em>rounding
 * policy</em>. The rounding policy is called a {@link
 * RoundingMode | rounding mode} for `BigDecimal` and called a
 * rounding-direction attribute in IEEE 754-2019. When the exact value
 * is not representable, the rounding policy determines which of the
 * two representable decimal values bracketing the exact value is
 * selected as the computed result. The notion of a <em>preferred
 * scale/preferred exponent</em> is also shared by both systems.
 *
 * For differences, IEEE 754 includes several kinds of values not
 * modeled by `BigDecimal` including negative zero, signed
 * infinities, and NaN (not-a-number). IEEE 754 defines formats, which
 * are parameterized by base (binary or decimal), number of digits of
 * precision, and exponent range. A format determines the set of
 * representable values. Most operations accept as input one or more
 * values of a given format and produce a result in the same format.
 * A `BigDecimal`'s {@link scale} is equivalent to
 * negating an IEEE 754 value's exponent. `BigDecimal` values do
 * not have a format in the same sense; all values have the same
 * possible range of scale/exponent and the {@link
 * unscaledValue | unscaled value} has arbitrary precision. Instead,
 * for the `BigDecimal` operations taking a `MathContext`
 * parameter, if the `MathContext` has a nonzero precision, the
 * set of possible representable values for the result is determined
 * by the precision of the `MathContext` argument. For example
 * in `BigDecimal`, if a nonzero three-digit number and a
 * nonzero four-digit number are multiplied together in the context of
 * a `MathContext` object having a precision of three, the
 * result will have three digits (assuming no overflow or underflow,
 * etc.).
 *
 * The rounding policies implemented by `BigDecimal`
 * operations indicated by {@link RoundingMode | rounding modes}
 * are a proper superset of the IEEE 754 rounding-direction
 * attributes.
 *
 * `BigDecimal` arithmetic will most resemble IEEE 754
 * decimal arithmetic if a `MathContext` corresponding to an
 * IEEE 754 decimal format, such as {@link MathContext.DECIMAL64 |
 * decimal64} or {@link MathContext.DECIMAL128 | decimal128} is
 * used to round all starting values and intermediate operations. The
 * numerical values computed can differ if the exponent range of the
 * IEEE 754 format being approximated is exceeded since a
 * `MathContext` does not constrain the scale of `BigDecimal`
 * results. Operations that would generate a NaN or exact infinity,
 * such as dividing by zero, throw a RangeError in
 * `BigDecimal` arithmetic.
 *
 */
export declare class BigDecimal {
    /**
     * Returns the signum function of this `BigDecimal`.
     *
     * @return -1, 0, or 1 as the value of this `BigDecimal`
     *         is negative, zero, or positive.
     */
    signum(): number;
    precision(): number;
    /**
     * Returns a `BigDecimal` whose value is `(-this)`,
     * with rounding according to the context settings.
     *
     * @param mc the context to use.
     * @return `-this`, rounded as necessary.
     */
    negate(mc?: MathContext): BigDecimal;
    /**
     * Returns a `BigDecimal` whose value is `(this + augend)`,
     * with rounding according to the context settings.
     *
     * If either number is zero and the precision setting is nonzero then
     * the other number, rounded if necessary, is used as the result.
     *
     * @param augend value to be added to this `BigDecimal`. This value will
     * be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return `this + augend`, rounded as necessary.
     */
    add(augend: BigDecimal | bigint | number | string, mc?: MathContext): BigDecimal;
    /**
     * Returns a `BigDecimal` whose value is `(this - subtrahend)`,
     * with rounding according to the context settings.
     *
     * If `subtrahend` is zero then this, rounded if necessary, is used as the
     * result.  If this is zero then the result is `subtrahend.negate(mc)`.
     *
     * @param subtrahend value to be subtracted from this `BigDecimal`. This value
     * will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return `this - subtrahend`, rounded as necessary.
     */
    subtract(subtrahend: BigDecimal | bigint | number | string, mc?: MathContext): BigDecimal;
    /**
     * Returns a `BigDecimal` whose value is <code>(this &times;
     * multiplicand)</code>, with rounding according to the context settings.
     *
     * @param multiplicand value to be multiplied by this `BigDecimal`. This
     * value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return `this * multiplicand`, rounded as necessary.
     */
    multiply(multiplicand: BigDecimal | bigint | number | string, mc?: MathContext): BigDecimal;
    /**
     * Returns a `BigDecimal` whose value is `(this / divisor)`,
     * and whose scale is as specified.  If rounding must
     * be performed to generate a result with the specified scale, the
     * specified rounding mode is applied.
     *
     * @param divisor value by which this `BigDecimal` is to be divided.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param scale scale of the `BigDecimal` quotient to be returned.
     * @param roundingMode rounding mode to apply.
     * @return `this / divisor`
     * @throws RangeError
     * * If `divisor` is zero
     * * If `roundingMode==RoundingMode.UNNECESSARY` and the specified scale is insufficient to represent the result
     *   of the division exactly.
     * * If scale is given but rounding mode is not given.
     */
    divide(divisor: BigDecimal | bigint | number | string, scale?: number, roundingMode?: RoundingMode): BigDecimal;
    /**
     * Returns a `BigDecimal` whose value is `(this /
     * divisor)`, with rounding according to the context settings.
     *
     * @param divisor value by which this `BigDecimal` is to be divided.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @throws RangeError if the exact quotient does not have a
     *         terminating decimal expansion, including dividing by zero
     * @return `this / divisor`
     */
    divideWithMathContext(divisor: BigDecimal | bigint | number | string, mc?: MathContext): BigDecimal;
    /**
     * Returns a `BigDecimal` whose value is the integer part
     * of `(this / divisor)`.  Since the integer part of the
     * exact quotient does not depend on the rounding mode, the
     * rounding mode does not affect the values returned by this
     * method.  The preferred scale of the result is
     * `(this.scale() - divisor.scale())`. A
     * `RangeError` is thrown if the integer part of
     * the exact quotient needs more than `mc.precision`
     * digits.
     *
     * @param divisor value by which this `BigDecimal` is to be divided.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return The integer part of `this / divisor`.
     * @throws RangeError if divisor is 0
     * @throws RangeError if `mc.precision > 0` and the result
     *         requires a precision of more than `mc.precision` digits.
     */
    divideToIntegralValue(divisor: BigDecimal | bigint | number | string, mc?: MathContext): BigDecimal;
    /**
     * Returns a `BigDecimal` whose value is `(this % divisor)`, with rounding according to the context settings.
     * The `MathContext` settings affect the implicit divide
     * used to compute the remainder.  The remainder computation
     * itself is by definition exact.  Therefore, the remainder may
     * contain more than `mc.getPrecision()` digits.
     *
     * The remainder is given by
     * `this.subtract(this.divideToIntegralValue(divisor,
     * mc).multiply(divisor))`.  Note that this is not the modulo
     * operation (the result can be negative).
     *
     * @param divisor value by which this `BigDecimal` is to be divided.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return `this % divisor`, rounded as necessary.
     * @throws RangeError if divisor is 0
     * @throws RangeError if the result is inexact but the
     *         rounding mode is `UNNECESSARY`, or `mc.precision`
     *         > 0 and the result of `this.divideToIntegralValue(divisor)` would
     *         require a precision of more than `mc.precision` digits.
     * @see    {@link divideToIntegralValue}
     */
    remainder(divisor: BigDecimal | bigint | number | string, mc?: MathContext): BigDecimal;
    /**
     * Compares this `BigDecimal` with the specified
     * object for equality.  Unlike {@link compareTo},
     * this method considers two `BigDecimal`
     * objects equal only if they are equal in value and
     * scale. Therefore 2.0 is not equal to 2.00 when compared by this
     * method since the former has [`BigInt`, `scale`]
     * components equal to [20, 1] while the latter has components
     * equal to [200, 2].
     *
     * One example that shows how 2.0 and 2.00 are **not**
     * substitutable for each other under some arithmetic operations
     * are the two expressions:
     *
     * ```
     * Big("2.0" ).divide(Big(3), undefined, HALF_UP) // which evaluates to 0.7
     *
     * Big("2.00").divide(Big(3), undefined, HALF_UP) // which evaluates to 0.67.
     *```
     *
     * @param value to which this `BigDecimal` is
     *         to be compared.
     * @return true if and only if the specified value is a
     *         BigDecimal whose value and scale are equal to this
     *         BigDecimal's.
     * @see    {@link compareTo}
     */
    equals(value: any): boolean;
    /**
     * Returns a two-element `BigDecimal` array containing the
     * result of `divideToIntegralValue` followed by the result of
     * `remainder` on the two operands calculated with rounding
     * according to the context settings.
     *
     * Note that if both the quotient and remainder are
     * needed, this method is faster than using the
     * `divideToIntegralValue` and `remainder` methods
     * separately because the division need only be carried out once.
     *
     * @param divisor value by which this `BigDecimal` is to be divided,
     *         and the remainder computed. This value will be converted to a
     *         `BigDecimal` before the operation. See the
     *         {@link Big | constructor} to learn more about the conversion.
     * @param mc the context to use.
     * @return a two element `BigDecimal` array: the quotient
     *         (the result of `divideToIntegralValue`) is the
     *         initial element and the remainder is the final element.
     * @throws RangeError if divisor is 0
     * @throws RangeError if the result is inexact but the
     *         rounding mode is `UNNECESSARY`, or `mc.precision > 0`
     *         and the result of `this.divideToIntegralValue(divisor)` would
     *         require a precision of more than `mc.precision` digits.
     * @see    {@link divideToIntegralValue}
     * @see    {@link remainder}
     */
    divideAndRemainder(divisor: BigDecimal | bigint | number | string, mc?: MathContext): [BigDecimal, BigDecimal];
    /**
     * Returns an approximation to the square root of `this`
     * with rounding according to the context settings.
     *
     * The preferred scale of the returned result is equal to
     * `this.scale()/2`. The value of the returned result is
     * always within one ulp of the exact decimal value for the
     * precision in question.  If the rounding mode is
     *  {@link RoundingMode.HALF_UP}, {@link RoundingMode.HALF_DOWN},
     * or {@link RoundingMode.HALF_EVEN}, the
     * result is within one half an ulp of the exact decimal value.
     *
     * @param mc the context to use.
     * @return the square root of `this`.
     * @throws RangeError if `this` is less than zero.
     * @throws RangeError if an exact result is requested
     * mc.getPrecision() is 0 and there is no finite decimal
     * expansion of the exact result
     * @throws RangeError if mc.getRoundingMode() is `RoundingMode.UNNECESSARY` and
     * the exact result cannot fit in `mc.getPrecision()`
     * digits.
     */
    sqrt(mc: MathContext): BigDecimal;
    /**
     * Returns the size of an ulp, a unit in the last place, of this
     * `BigDecimal`.  An ulp of a nonzero `BigDecimal`
     * value is the positive distance between this value and the
     * `BigDecimal` value next larger in magnitude with the
     * same number of digits.  An ulp of a zero value is numerically
     * equal to 1 with the scale of `this`.  The result is
     * stored with the same scale as `this` so the result
     * for zero and nonzero values is equal to `[1, this.scale()]`.
     *
     * @return the size of an ulp of `this`
     */
    ulp(): BigDecimal;
    /**
     * Returns a `BigDecimal` which is numerically equal to
     * this one but with any trailing zeros removed from the
     * representation.  For example, stripping the trailing zeros from
     * the `BigDecimal` value `600.0`, which has
     * [`BigInt`, `scale`] components equal to
     * [6000n, 1], yields `6E2` with [`BigInt`, `scale`]
     * components equal to [6n, -2].
     *
     * @return a numerically equal `BigDecimal` with any
     * trailing zeros removed.
     * @throws RangeError if scale from max or min safe integer range.
     */
    stripTrailingZeros(): BigDecimal;
    /**
     * Returns a `BigInt` whose value is the <i>unscaled
     * value</i> of this `BigDecimal`.  (Computes <code>(this *
     * 10<sup>this.scale()</sup>)</code>.)
     *
     * @return the unscaled value of this `BigDecimal`.
     */
    unscaledValue(): bigint;
    /**
     * Returns the <i>scale</i> of this `BigDecimal`.  If zero
     * or positive, the scale is the number of digits to the right of
     * the decimal point.  If negative, the unscaled value of the
     * number is multiplied by ten to the power of the negation of the
     * scale.  For example, a scale of `-3` means the unscaled
     * value is multiplied by 1000.
     *
     * The scale will be kept in the integer range, if cannot error will be thrown.
     *
     * @return the scale of this `BigDecimal`.
     */
    scale(): number;
    /**
     * Returns a BigDecimal whose numerical value is equal to
     * (`this` * 10<sup>n</sup>).  The scale of
     * the result is `(this.scale() - n)`.
     *
     * @param n the exponent power of ten to scale by
     * @return a BigDecimal whose numerical value is equal to
     * (`this` * 10<sup>n</sup>)
     * @throws RangeError if the scale would be outside the range of a safe integer.
     */
    scaleByPowerOfTen(n: number): BigDecimal;
    /**
     * Compares this `BigDecimal` numerically with the specified
     * `BigDecimal`.  Two `BigDecimal` objects that are
     * equal in value but have a different scale (like 2.0 and 2.00)
     * are considered equal by this method. Such values are in the
     * same <i>cohort</i>.
     *
     * This method is provided in preference to individual methods for
     * each of the six boolean comparison operators (`<`, `==`,
     * `>`, `>=`, `!=`, `<=`).  The suggested
     * idiom for performing these comparisons is:
     * (x.compareTo(y) &lt;<i>op</i>&gt; 0), where
     * &lt;<i>op</i>&gt; is one of the six comparison operators.

     * @param val value to which this `BigDecimal` is to be compared.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @return -1, 0, or 1 as this `BigDecimal` is numerically
     *          less than, equal to, or greater than `val`.
     * @see {@link sameValue}
     * @see {@link greaterThan}
     * @see {@link greaterThanOrEquals}
     * @see {@link lowerThan}
     * @see {@link lowerThanOrEquals}
     */
    compareTo(val: BigDecimal | bigint | number | string): number;
    /**
    * Alias for `compareTo(val) === 0`.
    * Consider using {@link equals} in case the scale needs to be considered.
    * @returns true if the value is the same as `val`
    * @see {@link equals}
    * @see {@link compareTo}
    */
    sameValue(val: BigDecimal | bigint | number | string): boolean;
    /**
     * Alias for `compareTo(val) > 0`.
     *
     * @param val value to which this `BigDecimal` is to be compared.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @returns true if the value is greater than `val`
     * @see     {@link compareTo}
     * @alias   {@link gt}
     */
    greaterThan(val: BigDecimal | bigint | number | string): boolean;
    /**
     * @alias {@link greaterThan}
     */
    gt(val: BigDecimal | bigint | number | string): boolean;
    /**
     * Alias for `compareTo(val) >= 0`.
     *
     * @param val value to which this `BigDecimal` is to be compared.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @returns true if the value is greater than or equals to `val`
     * @see     {@link compareTo}
     * @alias   {@link gte}
     */
    greaterThanOrEquals(val: BigDecimal | bigint | number | string): boolean;
    /**
     * @alias {@link greaterThanOrEquals}
     */
    gte(val: BigDecimal | bigint | number | string): boolean;
    /**
     * Alias for `compareTo(val) < 0`.
     *
     * @param val value to which this `BigDecimal` is to be compared.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @returns true if the value is lower than `val`
     * @see     {@link compareTo}
     * @alias   {@link lt}
     */
    lowerThan(val: BigDecimal | bigint | number | string): boolean;
    /**
     * @alias {@link lowerThan}
     */
    lt(val: BigDecimal | bigint | number | string): boolean;
    /**
     * Alias for `compareTo(val) <= 0`.
     *
     * @param val value to which this `BigDecimal` is to be compared.
     * This value will be converted to a `BigDecimal` before the operation.
     * See the {@link Big | constructor} to learn more about the conversion.
     * @returns true if the value is lower than or equals to `val`
     * @see     {@link compareTo}
     * @alias   {@link lte}
     */
    lowerThanOrEquals(val: BigDecimal | bigint | number | string): boolean;
    /**
     * @alias {@link lowerThanOrEquals}
     */
    lte(val: BigDecimal | bigint | number | string): boolean;
    /**
     * Converts this BigDecimal to number.
     * @return number for of this BigDecimal
     */
    numberValue(): number;
    /**
     * Returns a `BigDecimal` rounded according to the
     * `MathContext` settings.  If the precision setting is 0 then
     * no rounding takes place.
     *
     * The effect of this method is identical to that of the
     * {@link plus} method.
     *
     * @param mc the context to use.
     * @return a `BigDecimal` rounded according to the
     *         `MathContext` settings.
     * @see    {@link plus}
     */
    round(mc: MathContext): BigDecimal;
    /**
     * Returns a `BigDecimal` whose scale is the specified
     * value, and whose unscaled value is determined by multiplying or
     * dividing this `BigDecimal`'s unscaled value by the
     * appropriate power of ten to maintain its overall value.  If the
     * scale is reduced by the operation, the unscaled value must be
     * divided (rather than multiplied), and the value may be changed;
     * in this case, the specified rounding mode is applied to the
     * division.
     *
     *
     * @param newScale scale of the `BigDecimal` value to be returned.
     * @param roundingMode The rounding mode to apply. By default it is set to `UNNECESSARY`.
     * @return a `BigDecimal` whose scale is the specified value,
     *         and whose unscaled value is determined by multiplying or
     *         dividing this `BigDecimal`'s unscaled value by the
     *         appropriate power of ten to maintain its overall value.
     * @throws RangeError if roundingMode is `UNNECESSARY`
     *         and the specified scaling operation would require
     *         rounding.
     * @see {@link RoundingMode}
     */
    setScale(newScale: number, roundingMode?: RoundingMode): BigDecimal;
    /**
     * Returns a `BigDecimal` whose value is `(+this)`,
     * with rounding according to the context settings.
     *
     * The effect of this method is identical to that of the {@link round} method.
     *
     * @param mc the context to use.
     * @return `this`, rounded as necessary.  A zero result will
     *         have a scale of 0.
     * @see    {@link round}
     */
    plus(mc?: MathContext): BigDecimal;
    /**
     * Returns a `BigDecimal` whose value is
     * <code>(this<sup>n</sup>)</code>.  The current implementation uses
     * the core algorithm defined in ANSI standard X3.274-1996 with
     * rounding according to the context settings.  In general, the
     * returned numerical value is within two ulps of the exact
     * numerical value for the chosen precision.
     *
     * The X3.274-1996 algorithm is:
     *
     * * An `RangeError` exception is thrown if
     *     * `abs(n)` > 999999999
     *     * `mc.precision == 0` and `n < 0`
     *     * `mc.precision > 0` and `n` has more than
     *    `mc.precision` decimal digits
     *
     * * if `n` is zero, a BigDecimal with value 1 is returned even if
     * `this` is zero, otherwise

     *     * if `n` is positive, the result is calculated via
     *   the repeated squaring technique into a single accumulator.
     *   The individual multiplications with the accumulator use the
     *   same math context settings as in `mc` except for a
     *   precision increased to `mc.precision + elength + 1`
     *   where `elength` is the number of decimal digits in
     *   `n`.
     *
     *     * if `n` is negative, the result is calculated as if
     *   `n` were positive; this value is then divided into one
     *   using the working precision specified above.
     *
     *     * The final value from either the positive or negative case
     *   is then rounded to the destination precision.
     *
     * @param n power to raise this `BigDecimal` to.
     * @param mc the context to use.
     * @return <code>this<sup>n</sup></code> using the ANSI standard X3.274-1996
     *         algorithm
     * @throws RangeError if the result is inexact but the
     *         rounding mode is `UNNECESSARY`, or `n` is out
     *         of range.
     */
    pow(n: number, mc?: MathContext): BigDecimal;
    /**
     * Returns a `BigDecimal` whose value is the absolute value
     * of this `BigDecimal`, with rounding according to the
     * context settings.
     *
     * @param mc the context to use.
     * @return absolute value, rounded as necessary.
     */
    abs(mc?: MathContext): BigDecimal;
    /**
     * Compares half of second with first
     * @param first
     * @param second
     * @private
     */
    private static compareHalf;
    /**
     * Returns a `BigDecimal` which is equivalent to this one
     * with the decimal point moved `n` places to the left.  If
     * `n` is non-negative, the call merely adds `n` to
     * the scale.  If `n` is negative, the call is equivalent
     * to `movePointRight(-n)`.  The `BigDecimal`
     * returned by this call has value <code>(this &times;
     * 10<sup>-n</sup>)</code> and scale `max(this.scale()+n,
     * 0)`.
     *
     * @param n number of places to move the decimal point to the left.
     * @return a `BigDecimal` which is equivalent to this one with the
     *         decimal point moved `n` places to the left.
     * @throws RangeError if scale overflows.
     */
    movePointLeft(n: number): BigDecimal;
    /**
     * Returns a `BigDecimal` which is equivalent to this one
     * with the decimal point moved `n` places to the right.
     * If `n` is non-negative, the call merely subtracts
     * `n` from the scale.  If `n` is negative, the call
     * is equivalent to `movePointLeft(-n)`.  The
     * `BigDecimal` returned by this call has value <code>(this
     * &times; 10<sup>n</sup>)</code> and scale `max(this.scale()-n, 0)`.
     *
     * @param n number of places to move the decimal point to the right.
     * @return a `BigDecimal` which is equivalent to this one
     *         with the decimal point moved `n` places to the right.
     * @throws RangeError if scale overflows.
     */
    movePointRight(n: number): BigDecimal;
    /**
     * Returns the minimum of this `BigDecimal` and `val`.
     *
     * @param val value with which the minimum is to be computed.
     * @return the `BigDecimal` whose value is the lesser of this
     *         `BigDecimal` and `val`.  If they are equal,
     *         as defined by the {@link compareTo}
     *         method, `this` is returned.
     * @see    {@link compareTo}
     */
    min(val: BigDecimal): BigDecimal;
    /**
     * Returns the maximum of this `BigDecimal` and `val`.
     *
     * @param val value with which the maximum is to be computed.
     * @return the `BigDecimal` whose value is the greater of this
     *         `BigDecimal` and `val`.  If they are equal,
     *         as defined by the {@link compareTo}
     *         method, `this` is returned.
     * @see    {@link compareTo}
     */
    max(val: BigDecimal): BigDecimal;
    /**
     * Returns the string representation of this `BigDecimal`,
     * using scientific notation if an exponent is needed.
     *
     * A standard canonical string form of the `BigDecimal`
     * is created as though by the following steps: first, the
     * absolute value of the unscaled value of the `BigDecimal`
     * is converted to a string in base ten using the characters
     * '0' through '9' with no leading zeros (except
     * if its value is zero, in which case a single '0'
     * character is used).
     *
     * Next, an <i>adjusted exponent</i> is calculated; this is the
     * negated scale, plus the number of characters in the converted
     * unscaled value, less one.  That is,
     * `-scale+(ulength-1)`, where `ulength` is the
     * length of the absolute value of the unscaled value in decimal
     * digits (its <i>precision</i>).
     *
     * If the scale is greater than or equal to zero and the
     * adjusted exponent is greater than or equal to `-6`, the
     * number will be converted to a character form without using
     * exponential notation.  In this case, if the scale is zero then
     * no decimal point is added and if the scale is positive a
     * decimal point will be inserted with the scale specifying the
     * number of characters to the right of the decimal point.
     * '0' characters are added to the left of the converted
     * unscaled value as necessary.  If no character precedes the
     * decimal point after this insertion then a conventional
     * '0' character is prefixed.
     *
     * Otherwise (that is, if the scale is negative, or the
     * adjusted exponent is less than `-6`), the number will be
     * converted to a character form using exponential notation.  In
     * this case, if the converted `BigInt` has more than
     * one digit a decimal point is inserted after the first digit.
     * An exponent in character form is then suffixed to the converted
     * unscaled value (perhaps with inserted decimal point); this
     * comprises the letter 'E' followed immediately by the
     * adjusted exponent converted to a character form.  The latter is
     * in base ten, using the characters '0' through
     * '9' with no leading zeros, and is always prefixed by a
     * sign character '-' (<code>'&#92;u002D'</code>) if the
     * adjusted exponent is negative, '+'
     * (<code>'&#92;u002B'</code>) otherwise).
     *
     * Finally, the entire string is prefixed by a minus sign
     * character '-' (<code>'&#92;u002D'</code>) if the unscaled
     * value is less than zero.  No sign character is prefixed if the
     * unscaled value is zero or positive.
     *
     * **Examples:**
     * For each representation [<i>unscaled value</i>, <i>scale</i>]
     * on the left, the resulting string is shown on the right.
     * <pre>
     * [123,0]      "123"
     * [-123,0]     "-123"
     * [123,-1]     "1.23E+3"
     * [123,-3]     "1.23E+5"
     * [123,1]      "12.3"
     * [123,5]      "0.00123"
     * [123,10]     "1.23E-8"
     * [-123,12]    "-1.23E-10"
     * </pre>
     *
     * **Notes:**
     *
     * * There is a one-to-one mapping between the distinguishable
     * `BigDecimal` values and the result of this conversion.
     * That is, every distinguishable `BigDecimal` value
     * (unscaled value and scale) has a unique string representation
     * as a result of using `toString`.  If that string
     * representation is converted back to a `BigDecimal` using
     * the string constructor, then the original
     * value will be recovered.
     *
     * * The {@link toEngineeringString} method may be used for
     * presenting numbers with exponents in engineering notation, and the
     * {@link setScale} method may be used for
     * rounding a `BigDecimal` so it has a known number of digits after
     * the decimal point.
     *
     * @return string representation of this `BigDecimal`.
     */
    toString(): string;
    /**
     * Returns a string representation of this `BigDecimal`,
     * using engineering notation if an exponent is needed.
     *
     * Returns a string that represents the `BigDecimal` as
     * described in the {@link toString} method, except that if
     * exponential notation is used, the power of ten is adjusted to
     * be a multiple of three (engineering notation) such that the
     * integer part of nonzero values will be in the range 1 through
     * 999.  If exponential notation is used for zero values, a
     * decimal point and one or two fractional zero digits are used so
     * that the scale of the zero value is preserved.  Note that
     * unlike the output of {@link toString}, the output of this
     * method is <em>not</em> guaranteed to recover the same [number,
     * scale] pair of this `BigDecimal` if the output string is
     * converting back to a `BigDecimal` using the string constructor.
     * The result of this method meets the weaker constraint of always producing a numerically equal
     * result from applying the string constructor to the method's output.
     *
     * @return string representation of this `BigDecimal`, using
     *         engineering notation if an exponent is needed.
     */
    toEngineeringString(): string;
    /**
     * Returns a string representation of this `BigDecimal`
     * without an exponent field.  For values with a positive scale,
     * the number of digits to the right of the decimal point is used
     * to indicate scale.  For values with a zero or negative scale,
     * the resulting string is generated as if the value were
     * converted to a numerically equal value with zero scale and as
     * if all the trailing zeros of the zero scale value were present
     * in the result.
     *
     * The entire string is prefixed by a minus sign character '-'
     * (<code>'&#92;u002D'</code>) if the unscaled value is less than
     * zero. No sign character is prefixed if the unscaled value is
     * zero or positive.
     *
     * Note that if the result of this method is passed to the
     * string constructor, only the
     * numerical value of this `BigDecimal` will necessarily be
     * recovered; the representation of the new `BigDecimal`
     * may have a different scale.  In particular, if this
     * `BigDecimal` has a negative scale, the string resulting
     * from this method will have a scale of zero when processed by
     * the string constructor.
     *
     * @return a string representation of this `BigDecimal`
     * without an exponent field.
     * @see {@link toString}
     * @see {@link toEngineeringString}
     */
    toPlainString(): string;
    /**
     * Converts this `BigDecimal` to a `BigInt`.
     * Any fractional part of this will be discarded.  Note that this
     * conversion can lose information about the precision of the
     * `BigDecimal` value.
     *
     * To have an exception thrown if the conversion is inexact (in
     * other words if a nonzero fractional part is discarded), use the
     * {@link toBigIntExact} method.
     *
     * @return this `BigDecimal` converted to a `BigInt`.
     */
    toBigInt(): bigint;
    /**
     * Converts this `BigDecimal` to a `BigInt`,
     * checking for lost information.  An exception is thrown if this
     * `BigDecimal` has a nonzero fractional part.
     *
     * @return this `BigDecimal` converted to a `BigInt`.
     * @throws RangeError if `this` has a nonzero fractional part.
     */
    toBigIntExact(): bigint;
}
interface BigDecimalConstructor {
    (n: BigDecimal | bigint | number | string, scale?: number, mc?: MathContext): BigDecimal;
    new (n: BigDecimal | bigint | number | string, scale?: number, mc?: MathContext): BigDecimal;
}
/**
 * Constructor function for {@link BigDecimal}. Can be invoked with new or without new.
 *
 * The values passed must match one of Java BigDecimal's constructors, so the valid usages of this function is listed below:
 * ```javascript
 * Big(123n); // bigint, 123
 * Big(123n, 3); // bigint and scale, 0.123
 * Big(123n, 3, MC(2, RoundingMode.HALF_UP)); // bigint, scale and mc, 0.12
 * Big(aBigDecimal) // Copies the BigDecimal passed. "scale" and "mc" arguments will not used.
 * Big(123n, undefined, MC(2, RoundingMode.HALF_UP)); // bigint and mc, 1.2E+2
 * Big('1.13e12'); // string, 1.13E+12
 * Big('1.11e11', undefined, MC(2, RoundingMode.HALF_UP)); // string and mc, 1.1E+11
 * Big(10000); // number, 10000
 * Big(123, 5); // integer and scale, 0.00123
 * Big(1.1233, undefined, MC(2, RoundingMode.HALF_UP)); // number and scale, 1.1
 * ```
 *
 * Sample Usage:
 *```javascript
 * // Single unified constructor for multiple values
 * const { Big } = require('bigdecimal.js');
 *
 * // Construct from a string and clone it
 * const x = Big('1.1111111111111111111111');
 * const y = new Big(x); // you can also use 'new'
 *
 * const z = x.add(y);
 * console.log(z.toString()); // 2.2222222222222222222222
 *
 * // You can also construct from a number or BigInt:
 * const u = Big(1.1);
 * const v = Big(2n);
 *
 * console.log(u.toString()); // 1.1
 * console.log(v.toString()); // 2
 * ```
 *
 * @param n Any value to build a BigDecimal from. Types other than `Number` (as safe integer), `BigInt` and `BigDecimal`
 * will be internally converted to string and parsed.
 * @param scale Scale to use, by default 0.
 * @param mc MathContext object which allows you to set precision and rounding mode.
 * @throws RangeError on following situations:
 * * If value is a number:
 *     * Value is not in the range `[-Number.MAX_VALUE, Number.MAX_VALUE]`
 *     * Both a scale and a math context is provided. You can only give one of scale and math context.
 *       Passing `undefined` is same as omitting an argument.
 *     * If value is a double and scale is given.
 * * If value is not a `safe integer`, a `BigInt` or a `BigDecimal`, it will be converted to string.
 *   An error will be thrown if the string format is invalid.
 * * If value is not a `BigInt` or `number`, and scale is given.
 */
export declare const Big: BigDecimalConstructor;
interface MathContextConstructor {
    (precision: number, roundingMode?: RoundingMode): MathContext;
    new (precision: number, roundingMode?: RoundingMode): MathContext;
}
/**
 * Constructor function for {@link MathContext}. Can be invoked with new or without new.
 *
 * Sample Usage:
 * ```javascript
 * const { Big, MC, RoundingMode } = require('bigdecimal.js');
 *
 * const x = Big('1');
 * const y = Big('3');
 *
 * const res1 = x.divideWithMathContext(y, new MC(3));
 * console.log(res1.toString()); // 0.333
 *
 * // You can also use without `new` operator
 * const res2 = x.divideWithMathContext(y, MC(3, RoundingMode.UP));
 * console.log(res2.toString()); // 0.334
 *
 * try {
 *     x.divide(y);
 *     // throws since full precision is requested but it is not possible
 * } catch (e) {
 *     console.log(e); // RangeError: Non-terminating decimal expansion; no exact representable decimal result.
 * }
 * ```
 *
 * @param precision Precision value
 * @param roundingMode Optional rounding Mode. By default RoundingMode.HALF_UP.
 */
export declare const MC: MathContextConstructor;
export {};
