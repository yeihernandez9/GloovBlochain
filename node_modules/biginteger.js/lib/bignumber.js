(function(world) {
	var config = {
		defaultSize: 256
	};
	BigNumber.Negative = -1;
	BigNumber.Positive = 1;

	function complement(sign) {
		return sign === BigNumber.Positive ? BigNumber.Negative : BigNumber.Positive;
	}

	function parse(number, sign) {
		if (typeof number === 'string') {
			// parse the number and put it inside digits array.
			// trim the string.
			number = number.trim();
			// get the sign of the number.
			this.sign = sign || (number[0] === '-' ? BigNumber.Negative : BigNumber.Positive);
			// store digits in array in reverse order, helps during calculation.
			// get the end location.
			var end = 0;
			if (number[0] === '+' || number[0] === '-')
				end = 1;
			this.lastdigit = number.length - 1 - end;
			for (var i = number.length - 1, j = 0; i >= end; i--, j++) {
				this.digits[j] = parseInt(number[i]);
			}
		} else if (typeof number === 'object' && number instanceof BigNumber) {
			// copy digits from number to new bignumber object.
			for (var i = 0, len = number.digits.length; i < len; i++) {
				this.digits[i] = number.digits[i];
			}
			// copy lastdigit index.
			this.lastdigit = number.lastdigit;
			// if sign is given then make it as the new sign else take it from the number.
			this.sign = sign || number.sign;
		}
	}

	function compare(fn, a, b, considerSign) {
		var result = true; // 'this' is the big number.
		considerSign = considerSign === undefined ? true : considerSign;
		if (considerSign && a.sign !== b.sign) {
			result = a.sign === BigNumber.Positive ? true : false;
			if (fn === lt || fn === le)
				return !result;
			return result;
		} else {
			var start = Math.max(b.lastdigit, a.lastdigit);
			for (var i = start; i >= 0; i--) {
				if (fn(a.digits[i], b.digits[i])) {
					// current number is bigger than second number.
					break;
				} else {
					if (a.digits[i] !== b.digits[i]) {
						result = false;
						break;
					}
				}
			}
			if (!considerSign || (a.sign === BigNumber.Positive && b.sign === BigNumber.Positive))
				return result;
			else {
				// both are negative, so revert the result.
				return !result;
			}
		}
	}

	function gt(a, b) {
		return a > b;
	}

	function lt(a, b) {
		return a < b;
	}

	function ge(a, b) {
		return a >= b;
	}

	function le(a, b) {
		return a <= b;
	}

	function BigNumber(number, sign) {
		// initial configuration.
		this.digits = new Array(config.defaultSize); // array of digits.
		this.lastdigit = 0;
		this.sign = sign || BigNumber.Positive;
		// initialise
		for (var i = 0; i < config.defaultSize; i++)
			this.digits[i] = 0;
		// parse the number.
		parse.call(this, number, sign);
	}

	BigNumber.changeDefaultSize = function(size) {
		config.defaultSize = size || 128;
	};

	BigNumber.prototype.toString = function() {
		var n = this.sign === BigNumber.Positive ? '' : '-';
		for (var i = this.lastdigit; i >= 0; i--)
			n += this.digits[i];
		return n;
	};

	BigNumber.prototype.add = function(number, times) {
		var carry = 0;
		var result = new BigNumber(),
			a = this,
			b = number;

		if (a.sign === b.sign)
			result.sign = a.sign;
		else {
			b.sign = complement(b.sign);
			var ans = a.subtract(b, times);
			b.sign = complement(b.sign);
			return ans;
		}
		if (times && times !== 1) {
			b = b.multiply(new BigNumber(times + ''));
		}
		result.lastdigit = Math.max(a.lastdigit, b.lastdigit) + 1;
		var sum = 0;
		for (var i = 0; i <= result.lastdigit; i++) {
			sum = a.digits[i] + carry + b.digits[i];
			result.digits[i] = sum % 10;
			carry = parseInt(sum / 10);
		}
		result.correctLastDigitPosition();
		return result;
	};

	BigNumber.prototype.subtract = function(number, times) {
		var borrow = 0,
			result = new BigNumber();
		// if both are negative, just add and return the result.
		if ((this.sign === BigNumber.Negative && number.sign === BigNumber.Positive) || (this.sign === BigNumber.Positive && number.sign === BigNumber.Negative)) {
			number.sign = this.sign;
			result = this.add(number, times);
			number.sign = complement(this.sign);
		} else {
			var a = this,
				b = number,
				sign = a.sign;
			if (times && times !== 1) {
				b = b.multiply(new BigNumber(times + ''));
			}
			if (!a.greaterThan(b, false)) {
				var t = a;
				a = b;
				b = t;
				sign = complement(a.sign);
			}
			result.sign = sign;
			result.lastdigit = Math.max(a.lastdigit, b.lastdigit);
			var tmp = 0;
			for (var i = 0; i <= result.lastdigit; i++) {
				tmp = a.digits[i] - b.digits[i] - borrow;
				if (tmp < 0) {
					tmp += 10;
					borrow = 1;
				} else
					borrow = 0;
				result.digits[i] = tmp % 10; // modulo for safety.
			}
			result.correctLastDigitPosition();
		}
		return result;
	};

	BigNumber.prototype.multiply = function(number, times) {
		var a = this,
			b = number,
			row = a.clone(BigNumber.Positive),
			result = new BigNumber();
		if (times && times !== 1) {
			b = b.multiply(new BigNumber(times + ''));
		}
		for (var i = 0; i <= b.lastdigit; i++) {
			for (var j = 1; j <= b.digits[i]; j++) {
				result = result.add(row);
			}
			row.shiftRightBy(1);
		}
		result.sign = a.sign * b.sign;
		result.correctLastDigitPosition();
		return result;
	};

	BigNumber.prototype.divide = function(number, times) {
		// a / b ==> this / number.
		var result, a = this,
			b = number;
		if (b.isZero())
			throw Error('Division by zero.');
		if (b.sign === BigNumber.Negative) {
			b.sign = complement(b.sign);
			result = this.divide(b, times);
			b.sign = complement(b.sign);
			result.sign = a.sign * b.sign;
			return result;
		}
		if (a.sign === BigNumber.Negative) {
			a.sign = complement(a.sign);
			result = a.divide(number, times);
			a.sign = complement(a.sign);
			result.sign = a.sign * b.sign;
			return result;
		}
		// now both this and number are positive numbers.
		if (times && times !== 1) {
			b = b.multiply(new BigNumber(times + ''));
		}
		var row = new BigNumber();
		result = new BigNumber();
		result.lastdigit = a.lastdigit;
		for (var i = a.lastdigit; i >= 0; i--) {
			row.shiftRightBy(1);
			row.digits[0] = a.digits[i];
			result.digits[i] = 0;
			while (row.greaterThan(b)) {
				result.digits[i]++;
				row = row.subtract(b);
			}
		}
		result.correctLastDigitPosition();
		return result;
	};

	BigNumber.prototype.modulo = function(number) {
		var q = this.divide(number);
		return this.subtract(number.multiply(q));
	};

	BigNumber.prototype.pow = function(index) {
		var result = this.clone();
		if (index === 0) {
			return new BigNumber('1');
		} else if (index === 1) {
			return result;
		} else {
			for (var i = 2; i <= index; i++) {
				result = this.multiply(result);
			}
			return result;
		}
	}

	BigNumber.prototype.greaterThan = function(number, considerSign) {
		return compare(gt, this, number, considerSign);
	};

	BigNumber.prototype.lessThan = function(number, considerSign) {
		return compare(lt, this, number, considerSign);
	};

	BigNumber.prototype.greaterThanEqual = function(number, considerSign) {
		return compare(ge, this, number, considerSign);
	};

	BigNumber.prototype.lessThanEqual = function(number, considerSign) {
		return compare(le, this, number, considerSign);
	};

	BigNumber.prototype.clone = function(sign) {
		return new BigNumber(this, sign);
	};

	BigNumber.prototype.shiftRightBy = function(amt) {
		// number can be one digit also.
		if (this.lastdigit === 0 && this.digits[0] === 0)
			return;
		for (var i = this.lastdigit; i >= 0; i--) {
			this.digits[i + amt] = this.digits[i];
		}
		for (i = 0; i < amt; i++) {
			this.digits[i] = 0;
		}
		this.lastdigit = this.lastdigit + amt;
	};

	BigNumber.prototype.correctLastDigitPosition = function() {
		while (this.lastdigit > 0 && this.digits[this.lastdigit] === 0)
			this.lastdigit--;
	};

	BigNumber.prototype.isZero = function() {
		return this.digits[this.lastdigit] === 0;
	};

	if (world.exports)
		world.exports = {
			'BigNumber': BigNumber
		};
	else
		world.BigNumber = BigNumber;
})(module || window);